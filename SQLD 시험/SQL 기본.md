# SQL 기본





### Point 1 관계형 데이터베이스



관계형 데이터 베이스의 등장

* 1970년대  EF Codd 박사의 논문으로 처음 소개
* 렐레이시션과 렐레이션의 조인 연산을 통해서 합집합 교집합 차집합 등을 만들 수 있다.
* 편재 기업에서 가장 많이 사용하는 데이터베이스르 오라클 마이 에스큐엘 등등



#### 데이터베이스와 데이터베이스 관리 시스템의 차이점

* 데이터 베이스: 어떠한 형태의 자료구조로 사용하느냐에 따라 나누어지는데 계층형, 네트워크형, 관계형 등이 있다. 

  * 계층형: 트리형태의 구조로 데이터를 저장하고 관리한다. 1대 N관계를 표현한다.
  * 네트워크: 오너와 멤버형태로 데이터 저장.1대 N관계/  M 대N의 관계표현도 가능하다.
  * 관계형: 렐레이션에 데이터를 저장하고 관리한다. 이를 통해서 집합 연산과 관계연산관계를 할 수 있다.

* 데이터베이스 관리 시스템은 위의 형태들을 관리하기 위한 소프트웨어를 의미한다. DBMS 

* 집합연산

  * 합집합: 두개의 릴레이션을 하나로 합하는 것으로 중복된 행은 한 번만 조회된다.
  * 차집합: 본래 릴레이션아ㅔ는 존재하고 다른 렐레이션에는 존재하지 안흔 것을 조회한다.
  * 교집합: 두개의 릴레이션 간에 공통된 것을 조회한다.
  * 곱집합: 각 릴레이션에 존재하는 모든 데이터를 조합하여 연산한다.

* 관계 연산

  * 선택연산: 릴레이션에서 조건에 맞는 행만을 조회한다.
  * 투영 연산: 릴레이션에서 조건에 맞는 속성만을 조회한다.
  * 결합 연산: 여러 릴레이션의 공통된 속성을 사용해서 새로운 릴레이션을 만들어낸다.
  * 나누가 연산: 기준 릴레이션에서 나누는 릴레이션이 가지고 있는 속성과 동일한 값을 가직는 행(듀플)을 나누는 릴레이션의 속성을 삭제한 후 중복된 행을 제거하는 연산.

  

  

### 테이블 <= 릴레이션은 최족적으로 데이터 베이스 관리 시스템에서 테이블 생성



![테이블구조](C:\TIL\IMG\테이블구조.PNG)





* 기본키 : 하난의 테이블에서 유일성과 최소성을 만족하면서 해당테이블을 데표하는 것.

* 테이블은 행과 칼럼으로 구성된다. 그중에서 행은 하나의 테이블에 저장되는 값으로 튜플이라고 한다.

* 칼럼은 어떤 데이터를 저장하기 위한 필드로 속서잉라고 한다.

* 외레키는 다른 테이블의 기본키를 하는 칼럼이다. 예를 들어서   Employee  테이블에서 DNC 는 DNC 테이블의 기본키가 될 수 있다.

* 외래키는 관계연산 중에서 결합연산을 위해서 사용한다.

  



## Point 2 - SQL의 종류



### SQL(ANSI / ISO)

* 관계형 데이터베이스에 대해서 데이터 구조를 정의, 데이터 조작, 데이터 제어등을 할 수 있는 절차형 언어

  

  

### SQL의 종류

* DDL (Definition): 관계형 데이터베이스의 구조를 정의하는 언어로  **Create Alter Drop Rename** 등이 있다.
  * 데이터베이스 테이블을 생성하거나 변경, 삭제하는 것으로 데이터를 저장할 구조를 정의하는 언어
* DML(Manipulation) : 테이블에서 데이터를 입력 수정 삭제 조회를 한다 i**nsert update select** 등이 있다.
  * DDL로 구조가 정의가 더ㅚ면 해당 데이터 구조에 데이터를 조정한다. 입력 수정 삭제 등등
* DCL (control): 데이터 베이스 사용자에게 권한을 부여하거나 회수 한다.  **grant revoke** 등이 있다
  * DDL로 사용자에 대한 데이토 접근 권한 부여
* TCL (tarnsaction control language) : 트랜잭션을 제어하는 명렁어 **commit Rollback**등이 있다



#### 트랜젝션 (transaction)

: 데이터베이스의 작업을 처리하는 단위



#### 트랜젝션의 특성

* 원자성 :  트랜잭션은 데이터베이스 연산의 전부 또는 일부(ALL or NOTHING) 실행만 있다. 트랙잭션 처리가 완전히 끝나지 않았을 경우는 전혀 이루어지지 않는 것과 같아야 한다.
* 일관성 : 트랜잭션 실행 결과로 데이터베이스의 상태가 모순되지 않아야 한다. 트랜잭션 실행 후에도 일관성이 유지되어야 한다. 
* 고립성 :  트랜잭션 실행 중에 생성하는 연산의 중간결과는 다른 트랜잭션이 접근할 수 없다. 즉 부분적인 실행결과를 다른 트랜잭션이 볼 수 없다.
* 연속성 : 트랜잭션이 그 실행을 성공적으로 완료하면 그 결과는 영구적 보장이 되어야 한다.



#### SQL문의 실행 순서

: D - M - C  순으로 실행이 된다.  or 

1. 파싱 (SQL문의 문법을 확인하고 구문분석 한다. 구문 분석한 SQL문은 library cache 에 저장한다.)
2. 실행 :  옵티마이저가 수립한 실행계획에 따라 SQL을 실행하나다.
3. 인출 : 데이터를 읽어서 전송한다.



## Point 3 - DDL(definition**)**

1. **칼럼 추가**

* **Create table** : 새로운 테이블을 생성한다. 테이블 생성할 때 기본키 외래키 기타 제약사항등을 설정

  * create table EMP 라고 명령어를 하면EMP 테이블을 생성하는 것이다. (); 이 사이에 칼럼 정보를 넣어줌
  * 칼럼 정보: 칼럼 이름과 데이이터 타입을 입력 칼람 이름은 영문자로
  * 데이터 타입은 number varchar2 등이 있고 뒤에 오는 숫자는 길이를 조절하는 것
  * 기본키를 입력을 할 때는 뒤에 primary key라고 쓴다.

* 제약조건 사용

  * 기본키를 지정하거나 외랙키 기본값 not null등은 테이블 생성할 때 지정할 수 있다.
  * ex) : constraint emppk primary key(empno)  // contstraint 를이용하면 기본키를 지정할 수 있다. 그리고 기본키가 두개일 경우에 주로 사용한다.
  * number(10,2) 일경우에는 소수점 둘째 자리까지 저장하게된다.
  * sysdate 오늘의 날짜를 조회한다. 그래서 default 옵션으로 사용하면 오늘 날짜를 기본으로 사용한다.
  * 외래기(foreign key)를 지정하려 하면, 먼저 마스터 테이블이 생성되어야 한다. 즉 사원과 부서 테이블에서는 부서가 마스터 테이블이다.
  * contstraint 를 이용해서 외래키를 설정 할 수 있따.

* 테이블 생성시에 CASCADE 

  * 이 옵션은 참조관계(기본키와 외래키 관계)가 있을 경우 찾조되는 데이터도 자동으로 삭제할 수 있는 것
  * 먼저 마스터 테이블을 생성한다. 그리고 데이터를 넣어준다. 

  ```
  create table dept
  
  (
  	deptno varchar2(4) primary key,
  	deptname varchar2(20)
  );
  
  insert into dept values ('1000'.'인사팀');
  insert into dept values ('1001'.'총무팀');
  ```

  

  * 그리고 emp 테이블을 생성하고 데이터를 입력한다. 단 emp테이블을 생성 할 때 on delete Cascade를 사용한다. emp 테이블에 데이터를 입력을 한다. 

    

  ```
  create table emp(
  	
  	empno number(10),
  	ename varchar2(20),
  	sal number(10,2) default 0,
  	.
  	.
  	.
  	
  	reference depte(deptno)
  	ON DELETE CASCADE
  );
  
  insert into emp values(100,'임베스트',1000, '1000' .....)
  insert into emp values(100,'임베스트',1000, '1001' .....)
  
  
  ```

  

  * 이렇게 되면 deptno 가 1000인 사람의 정보를 삭제했다. 그리고 emp 테이블의 1000또한 삭제가 된다. 이를 통해서  참조 무결성을 준수 할 수가 있다.

    

  2. **칼럼 변경**

     

* **Alter table**: 생성된 테이블을 변경한다. 칼럼을 추가하거나 변경 삭제할 수 있다. 기본키를 설정하거나, 외래키를 설정할 수 있다.

  * 칼럼 변경은 : alter table ~ modify 문을 사용하고 데이터 타입을 변경하거나 길이 변경

  * 칼럼 변경할 때 제쟉조건을 설정할 수도 있다.

  * 칼럼데이터 타입을 변경할 때 기존의 데이터가 이쓰염 에러가 난다.

    

  3. **칼럼삭제**: alter table drop column [컬럼 명]
  4. **칼렴명 변경** : alther table rename column [이전 이름] to [새이름]





* **Drop table** **(테이블 삭제):** 해당 테이블을 삭제한다. 이 명령어를 사용을 할 시 구조뿐만 아니라 저장된 데이터도 모두 삭제된다. 
  * drop table 에서 'Cascade constraint'옵션을 사용하면 참조된 제약 사항도 모두 삭제하는 것이다.



#### 뷰 생성과 삭제

* 뷰란 테이블로 부터 유도된 가상 테이블이다. 

* 실제 데이터를 가지고 있지 않고 테이블을 참조해서 원하는 칼럼만을 조회할 수 있게 한다.

* 뷰는 데이터 딕셔너리에ㅜ SQL문 현태로 저장하고 실행 시 참조된다.

  * **특징**

  * **참조한 테이블이 변경되면 뷰도 변경된다.**

  * 뷰의 검색은 참조한 테이블과 동일하게 할 수 있지만, 뷰**에 대한 입력 수정 삭제에는 제약이 발생한다.**

  * 특정 칼럼만 조회시켜서 보안성을 향상시킨다.

  * 한번 생성된 뷰는 변경할 수 없고 변경을 ㅎ원하면 삭제후 재생성 하애한다.

    

    1. 뷰 생성은 create view 그리고 참조해야 하는 에티블을 지정해야 한다.
    2. 뷰를 생성 할 때 select문을 사용하고 참조되는 테이블을 지정하는 것
    3. 뷰 조회는 select문을 사용해서 일반 테이블 처럼 조회한다.
    4. 뷰의 삭제는 drop view 를 사용 한다. 뷰를 삭제했다고 해서 참조했던 에티블이 삭제되지는 않는다.

    

    ##### 뷰의 장점

    * 특정 칼럼만 조회할 수 있기 때문에 보안기능이 있다.
    * 데이터 관리가 간단하다
    * select문이 간단해진다.
    * 하나의 테이블에 여러개의 뷰를 생성할 수 있다.

    

    ##### 뷰의 단점

    * 뷰는 독자적인 인덱스를 만들 수 없다.
    * 삽입 수정 삭제 연산이 제약된다.
    * 데이터 구조를 변할 수 없다.



## Point 4 DML (Manipulation)



### insert 문



~~~
 insert into [table 명](column1(명),column2 ... ) values (expression1(값),expression1...);
 
~~~



* emp 테이블에 데이터를 삽입하려면 테이블명, 칼러명 데이터 순으로 입력하면된다.
* 데이터를 입력할 때 문자열을 입력하는 경우에는 ' '을 사용해야 한ㄷ.



~~~
insert into emp values (1000,'임베스트')
~~~



* 특정 테이블의 모든 칼럼에 삽입하는 경우에는 칼람명을 생략할 수 있다.
* 단 위의 예제 처럼 emp 테이블의 칼럼은 숫자형 데이터타입 한개와 문자형 데이터 타입 한 컬럼만 있어야함.
* insert 문을 한 후에는 최종적으로 저장을 하기 위해서는  Commit(DCL)을 해줘야함



#### Select 문으로 입력

pass



#### Nologging 사용

* check point 라는 이벤트가 발생하면 로그 파일의 데이터를 데이터 파일에 저장한다.

* Nologging 옵션은 로그파일의 기록을 최소화시켜서 입력 시에 성능을 향상시키는 방법이다.

* buffer cashe  라는 메모리 영역을 생략하고 기록한다.

  



### update 문

*  입력된 데이터값을 수정할 때 사용
* 업데이트에 조건문을 입력하지 않으면 모든 데이터가 수정되므로 유의해야함



~~~
update emp // 수정되는 테이블

	set ename = 'WL'  / ename 칼럼의 값을 WL로 변경
	where enpno = 100;  / 수정을 원하는 데이터 검색
~~~



* 위의 예제가 진행이 되면 empno 가 100이면 모든 데이터의 ename 이 'WL'로 바뀌게 된다.



### delete 문

* 위와 마찬가지로 delete 문또한 조건이 없으면 모든 데이터가 삭제된다. 
* delete 문으로 데이터를 삭제한다고 해서 테이블의 용량이 초기화 되지않는다.



#### < tip >

>   오라클 데이터베이스는 저장 공간을 할당 할 때 Extent 단위로 할당한다. 그런데 이 할당된 단위보다 많은 양의 데이터가 입력이 되어지면 용량초가 오류가 발생하게 된다. **<u>즉, 최대 저장 공간이 있다는 것을 의미한다.</u>**



* delete from 테이블 명;
  *  테이블의 모든 데이터를 삭제를 하지만, 테이블의 용량이 감소되지는 않는다.
* truncate table 테이블 명;
  * 테이블의 모든 데이터를 삭제하고, 에티블 용량또한 초기화가 된다.





### Select 문



: 테이블에 입력되는 데이터를 조회하기 위해서 사용한다. 



~~~ 
select * from emp 
where empno = 1000;
~~~



~~~ 
select ename || '님' from emp;

emp 테이블에서 모든 ename 칼럼을 조회를 하고 뒤에 '님'자와 결합을 해서 찾아내게 된다.
그래서 'WL님' 이라고 출력이 된다.
~~~





##### order by(특별한 지정이 없다면 오름차순)

: 데이터를 오름차순 혹은 내림 차순으로 출력한다. order by를 사용을 할 때 정렬을 해야 하기 때문에 데이터베이스의 메모리를  많이 사용하게 되어 성능 저하 현상이 발생한다. 그래서 SORT_AREA_SIZE를 사용한다. 하지만 이또한 작다면 역시 성능 저하현상이 발생하게 된다.

성능 저하현상을 피하기 위해서 사전에 인덱스를 생성 할 때 사용자가 원하는 형태의 차순으로 생성해야 한다.



..... 



> 아래 부터는 이제 확실히 모르는 부분만 써보고 나머지는 문제로 확인을 해볼듯함.



#### Null 관련 함수

* NVL 함수 
  * null 이면 다른 값으로 바꾸는 함수이다. 
  * ex) 'nvl(mgr,0)'은 mgr 칼럼이 null이면 0으로 바꾼다.
* NVL2 함수
  * nvl 함수와 decode를 하나로 만든 것이다.
  * ex) 'nvl2(mgr.1.0)'은 mgr 칼럼이 null  이 아니면 1을  null이면 0을 반환한다.
* nullif 함수
  * 두 개의 값이 같으면 null 을 같지 않으면 첫번째 값을 반환한다.
  * 'nullif(exp1,exp2)'은  exp1 과 exp2 가 같은면 null값을 / 같지 않으면 exp1을 반환한다.
* coalesce
  * coalesce(mgr ,1)은 mgr 이 null이 아니면 1을 반환한다.





#### group by 문

#### having : group by 문에 조건을 걸기 위해서 사용



**COUNT  함수를 이용하면 null값은 제외하고 행수를 계산한다.**



#### select 문의 실행 순서 !!!

:from - where - group by - having - select - order by 



#### 명시적 형변환 / 암시적 형변환

명시적 형변환 :  함수를 사용해서 데이터 타입을 일치 시키는 것.

* to_number/char/date : 문자열을 숫자로 변환한다. 숫자를 문자열로/ 문자열을 날짜형으로



암시적 형변환: 개발자가 형변환을 하지 않ㄴ은 경우 데이터베이스 관리 시슽템이 자동으로 형변환 하는 경우



### Tip

#### 인덱스 칼럼에 형변환을 수행하면 인덱스를 사용하지 못한다.

#### so 그래서 명시적 형변환을 사용하면 된다. 

```
where empno=to_number('100') 으로 하면 empno칼럼이 변환되지 않아서 인덱스를 사용할 수 있다.
```





## Point 9  - 내장형 함수



앞에서 배운 내장형 함수로는 형변환 함수 문자열 및 숫자형 함수, 날짜형 함수가 있다.



#### Dual 테이블(내장형 함수를 사용할 때 사용)

* ACS||(문자) :  문자 혹은 숫자를 ACS||코드 값으로 변환한다.

* CHAR(ACS|| 코드 값) : ACS||코드 값을 문자로 변환한다.

* SUBSTR(문자열,M,N) : 문자열에서 M번째 N개를 짜른다.

* CONCAT(문자열1 ,문자열2) : 문자열 1 과 문자열 2를 결합한다.

* LOWER(문자열): 영문자를 소문자로 변환한다.

* UPPER(문자열): 영문자를 대문자로 변환한다.

* LENGTH 혹은 LEN(문자열): 공백을 포함해서 문자열의 길이를 알려준다.

* LTRIM(문자열. 지정문자) / RTRIM(문자열. 지정문자) : 왼쪽에 지정된 문자를 삭제한다. 지정된 문자를 생략하면 공백을 삭제한다. / 반대

* TRIM(문자열, 지정된 문자.) : 왼쪽에서 오른쪽에 지정된 문자를 삭제한다.

* SYSDATE 오늘의 날짜를 날짜형 타입으로 알려준다.

* EXTRACT('YEAR|'MONTH'|'DAY' FROM D) : 날짜에서 년 월 일을 조회한다.

* ABS(숫자) : 절대값을 돌려준다( = 부호를 없앤다).

* SIGN(숫자) : 양수 음수 0을 구별한다.

* MOD(숫자1 , 숫자 2) : 숫자1 과 숫자 2로 나누어서 나머지를 계산한다. %를 사용해도 된다.

* CEIL/CEILING(숫자) : 숫자보다 크거나 같은 최소의 정수를 돌려준다.

* FLOOR(숫자) :  숫자보다 크거나 같은 ㄷ최대의 정수를 돌려준다.

* ROUND(숫자,M) :  소수점 M자리에서 반올림한다.

* TRUNC(숫자,M): 소수점 M자레에서 절삭한다.

  



#### DECODE 

: 디코드 문으로 IF문을 구현 할 수 있다.

~~~
DECODE(EMPNO,1000,'TRUE','FALSE')
FROM EMP;

=> 해석: EMPNO DPTJ 1000과 비교해서 같으면 TRUE 틀리면 FALSE를 출력하게 된다.
~~~



 

#### CASE 문 

: 머일 때 머이다. 

```
WHEN ~~~~~ THEN 'xxxx'
.
.
.
ELSE 'XXXX'
END
FROM EMP;
```



#### ROWNUM / ROWID



#### ROWNUM

* SELECT 문의 결과에 대해서 논리적인 일려번호를 부여한다.
* 조회되는 행수를 제한할 때 많이 사용된다.
* 한개의 행을 가지고 올수 있으나, 여러개의 행을 가지고 올 때는 INLINE VIEW를 사용해야 한다.



#### ROWID

* 이 명령어는 오라클  DB에서 유ㅜ일하게 데이터를 구분 할 수 있는 값
* 데이터가 어떤 데이터 파일 어떤 블록에 저장되어 있는 지를 알 수 있다.
  * 오브젝트 번호 1~6 : 오브젝트 별로 유일한 값을 가지고 있으며 해당 오브젝트가 속해있는 값
  * 상대파일번호  7~9 : 테이블 스페이스에 속해 있는 데이터 파일에 대한 상대파일 번호
  * 블록번호 10 ~15: 데이터 파일 내부에서 어느 블록에 데이터가 있는 지 알려준다.
  * 데이터번호 16~18 : 데이터 블록에 데이터가 저장되어있는 순서를 의미



### WITH 구문

: 서브 쿼리를 이용해서 임시 테이블이나 뷰처럼 사용할 수 있는 구문이다. 서브쿼리 블록에 별칭을 지정할 수있다. 





### POINT 13 - DCL(CONTROL)



#### GRANT

: 사용자에게 권한을 부여한다. 권한을 부여하게 되면 연결 입력 수정 삭제 조회등을 할 수 있다.



~~~
GRANT privileges ON object TO user;

privileges (select, insert , update, .....)는 권한을 의미하며 object는 테이블 명이다. 
~~~



#### with grant option

* with grant option 
  * 특정 사용자에게 권한을 부여할 수 있는 권한을 부여한다.
  * 권한을 A 사용자가 B에 부여하고 B가 다시 C를 부여한 후에 권한을 취소 하면 모든 권한이 회수가 된다.
*  with admin option 
  * 테이블에 대한 모든 권한을 부여한다.



#### revoke

모든 권한을 회수한다.



```
revoke privieleges on object from user;
```



### POINT 14 - TCL(TANSACTION CONTROL)



### COMMIT 

* 변견한 데이터를 데이터베이스에 반영한다.
* 변경전 데이터는 잃어버린다.
* 트랜잭션 과정을 종료한다.



### ROLLBACK

* 데이터에 대한 변경사항을 취소하고 드랜잭션을 종료한다. 이전의 모든 작업을 취소하고. 이전에 COMMIT한 곳까지만 복구가 된다.





###  SAVE POINT

* 트랜잭션을 작게 분할하여 관리하는 것으로 SAVEPOINT 를 사용하면 지정된 위치까지만 ROLLBACK 할수 있다.

## QQ

1. 트랜잭션의 원자성을 설명을 보고 잘 이해가 되지 않음. 왜 저게 원자성인가?

   